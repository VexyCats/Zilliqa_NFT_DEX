"use strict";
//  This file is part of Zilliqa-Javascript-Library.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var account_1 = require("@zilliqa-js/account");
var crypto_1 = require("@zilliqa-js/crypto");
var util_1 = require("@zilliqa-js/util");
var core_1 = require("@zilliqa-js/core");
var util_2 = require("./util");
var Blockchain = /** @class */ (function () {
    function Blockchain(provider, signer) {
        this.provider = provider;
        this.provider.middleware.request.use(account_1.util.formatOutgoingTx, "CreateTransaction" /* CreateTransaction */);
        this.signer = signer;
    }
    /**
     * getBlockChainInfo
     *
     * @returns {Promise<RPCResponse<BlockchainInfo, string>>}
     */
    Blockchain.prototype.getBlockChainInfo = function () {
        return this.provider.send("GetBlockchainInfo" /* GetBlockchainInfo */);
    };
    /**
     * getShardingStructure
     *
     * @returns {Promise<RPCResponse<ShardingStructure, string>>}
     */
    Blockchain.prototype.getShardingStructure = function () {
        return this.provider.send("GetShardingStructure" /* GetShardingStructure */);
    };
    /**
     * getDSBlock
     *
     * Get details of a Directory Service block by block number.
     *
     * @param {number} blockNum
     * @returns {Promise<RPCResponse<DsBlockObj, string>>}
     */
    Blockchain.prototype.getDSBlock = function (blockNum) {
        return this.provider.send("GetDsBlock" /* GetDSBlock */, blockNum.toString());
    };
    /**
     * getLatestDSBlock
     *
     * Get details of the most recent Directory Service block.
     *
     * @returns {Promise<RPCResponse<DsBlockObj, string>>}
     */
    Blockchain.prototype.getLatestDSBlock = function () {
        return this.provider.send("GetLatestDsBlock" /* GetLatestDSBlock */);
    };
    /**
     * getNumDSBlocks
     *
     * Gets the number of DS blocks that the network has processed.
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    Blockchain.prototype.getNumDSBlocks = function () {
        return this.provider.send("GetNumDSBlocks" /* GetNumDSBlocks */);
    };
    /**
     * getDSBlockRate
     *
     * Gets the average rate of DS blocks processed per second
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    Blockchain.prototype.getDSBlockRate = function () {
        return this.provider.send("GetDSBlockRate" /* GetDSBlockRate */);
    };
    /**
     * getDSBlockListing
     *
     * Get a paginated list of Directory Service blocks. Pass in page number as
     * parameter. Returns a maxPages variable that specifies the max number of
     * pages. 1 - latest blocks, maxPages - oldest blocks.
     *
     * @param {number} max
     * @returns {Promise<RPCResponse<BlockList, string>>}
     */
    Blockchain.prototype.getDSBlockListing = function (max) {
        return this.provider.send("DSBlockListing" /* DSBlockListing */, max);
    };
    /**
     * getTxBlock
     *
     * Get details of a Transaction block by block number.
     *
     * @param {number} blockNum
     * @returns {Promise<RPCResponse<TxBlockObj, string>>}
     */
    Blockchain.prototype.getTxBlock = function (blockNum) {
        return this.provider.send("GetTxBlock" /* GetTxBlock */, blockNum.toString());
    };
    /**
     * getLatestTxBlock
     *
     * Get details of the most recent Transaction block.
     *
     * @returns {Promise<RPCResponse<TxBlockObj, string>>}
     */
    Blockchain.prototype.getLatestTxBlock = function () {
        return this.provider.send("GetLatestTxBlock" /* GetLatestTxBlock */);
    };
    /**
     * getNumTxBlocks
     *
     * Gets the total number of TxBlocks.
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    Blockchain.prototype.getNumTxBlocks = function () {
        return this.provider.send("GetNumTxBlocks" /* GetNumTxBlocks */);
    };
    /**
     * getTxBlockRate
     *
     * Gets the average number of Tx blocks per second.
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    Blockchain.prototype.getTxBlockRate = function () {
        return this.provider.send("GetTxBlockRate" /* GetTxBlockRate */);
    };
    /**
     * getTxBlockListing
     *
     * Get a paginated list of Transaction blocks. Takes a page number as
     * parameter, where each page contains a list of 10 blocks (max). Returns
     * a maxPages variable that specifies the max number of pages. 1 - latest
     * blocks, maxPages - oldest blocks.
     *
     * @param {number} max
     * @returns {Promise<RPCResponse<BlockList, string>>}
     */
    Blockchain.prototype.getTxBlockListing = function (max) {
        return this.provider.send("TxBlockListing" /* TxBlockListing */, max);
    };
    /**
     * getNumTransactions
     *
     * Gets the number of transactions processed by the network so far.
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    Blockchain.prototype.getNumTransactions = function () {
        return this.provider.send("GetNumTransactions" /* GetNumTransactions */);
    };
    /**
     * getTransactionRate
     *
     * Gets the number of transactions processed per second
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    Blockchain.prototype.getTransactionRate = function () {
        return this.provider.send("GetTransactionRate" /* GetTransactionRate */);
    };
    /**
     * getCurrentMiniEpoch
     *
     * Gets the current Tx Epoch.
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    Blockchain.prototype.getCurrentMiniEpoch = function () {
        return this.provider.send("GetCurrentMiniEpoch" /* GetCurrentMiniEpoch */);
    };
    /**
     * getCurrentDSEpoch
     *
     * Gets the current DS Epoch.
     *
     * @returns {Promise<RPCResponse<any, string>>}
     */
    Blockchain.prototype.getCurrentDSEpoch = function () {
        return this.provider.send("GetCurrentDSEpoch" /* GetCurrentDSEpoch */);
    };
    /**
     * getPrevDifficulty
     *
     * Gets shard difficulty for previous PoW round
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    Blockchain.prototype.getPrevDifficulty = function () {
        return this.provider.send("GetPrevDifficulty" /* GetPrevDifficulty */);
    };
    /**
     * getPrevDSDifficulty
     *
     * Gets DS difficulty for previous PoW round
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    Blockchain.prototype.getPrevDSDifficulty = function () {
        return this.provider.send("GetPrevDSDifficulty" /* GetPrevDSDifficulty */);
    };
    /**
     * createTransaction
     *
     * Creates a transaction and polls the lookup node for a transaction
     * receipt. The transaction is considered to be lost if it is not confirmed
     * within the timeout period.
     *
     * @param {Transaction} tx
     * @param {number} maxAttempts - (optional) number of times to poll before timing out
     * @param {number} number - (optional) interval in ms
     * @returns {Promise<Transaction>} - the Transaction that has been signed and
     * broadcasted to the network.
     */
    Blockchain.prototype.createTransaction = function (tx, maxAttempts, interval, blockConfirm) {
        if (maxAttempts === void 0) { maxAttempts = core_1.GET_TX_ATTEMPTS; }
        if (interval === void 0) { interval = 1000; }
        if (blockConfirm === void 0) { blockConfirm = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response, err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.provider.send("CreateTransaction" /* CreateTransaction */, tslib_1.__assign(tslib_1.__assign({}, tx.txParams), { priority: tx.toDS }))];
                    case 1:
                        response = _a.sent();
                        if (response.error) {
                            throw response.error;
                        }
                        if (blockConfirm) {
                            return [2 /*return*/, tx.blockConfirm(response.result.TranID, maxAttempts, interval)];
                        }
                        return [2 /*return*/, tx.confirm(response.result.TranID, maxAttempts, interval)];
                    case 2:
                        err_1 = _a.sent();
                        throw err_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Blockchain.prototype.createTransactionWithoutConfirm = function (tx) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response, err_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.provider.send("CreateTransaction" /* CreateTransaction */, tslib_1.__assign(tslib_1.__assign({}, tx.txParams), { priority: tx.toDS }))];
                    case 1:
                        response = _a.sent();
                        if (response.error) {
                            throw response.error;
                        }
                        tx.id = response.result.TranID;
                        return [2 /*return*/, tx];
                    case 2:
                        err_2 = _a.sent();
                        throw err_2;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * getTransaction
     *
     * Retrieves a transaction from the blockchain by its hash. If the result
     * contains an Error, a rejected Promise is returned with the erorr message.
     * If it does not contained an error, but `receipt.success` is `false`, then
     * a rejected Transaction instance is returned.
     *
     * @param {string} txHash
     * @returns {Promise<any>}
     */
    Blockchain.prototype.getTransaction = function (txHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response, err_3;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.provider.send("GetTransaction" /* GetTransaction */, txHash)];
                    case 1:
                        response = _a.sent();
                        if (response.error) {
                            return [2 /*return*/, Promise.reject(response.error)];
                        }
                        return [2 /*return*/, response.result.receipt.success
                                ? account_1.Transaction.confirm(util_2.toTxParams(response), this.provider)
                                : account_1.Transaction.reject(util_2.toTxParams(response), this.provider)];
                    case 2:
                        err_3 = _a.sent();
                        throw err_3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * getRecentTransactions
     *
     * Gets a list of recent transactions
     *
     * @returns {Promise<RPCResponse<TxList, never>>}
     */
    Blockchain.prototype.getRecentTransactions = function () {
        return this.provider.send("GetRecentTransactions" /* GetRecentTransactions */);
    };
    /**
     * getTransactionsForTxBlock
     *
     * Gets all transactions for a given TxBlock, grouped by shard id
     *
     * @param {number} txBlock
     * @returns {Promise<RPCResponse<string[][], string>>}
     */
    Blockchain.prototype.getTransactionsForTxBlock = function (txBlock) {
        return this.provider.send("GetTransactionsForTxBlock" /* GetTransactionsForTxBlock */, txBlock.toString());
    };
    /**
     * getNumTxnsTxEpoch
     *
     * Gets the number of transactions procesed for a given Tx Epoch.
     *
     * @param {number} epoch
     * @returns {Promise<RPCResponse<number, never>>}
     */
    Blockchain.prototype.getNumTxnsTxEpoch = function (epoch) {
        return this.provider.send("GetNumTxnsTxEpoch" /* GetNumTxnsTxEpoch */, epoch);
    };
    /**
     * getNumTxnsDSEpoch
     *
     * Gets the number of transactions procesed for a given DS Epoch.
     *
     * @param {number} epoch
     * @returns {Promise<any>}
     */
    Blockchain.prototype.getNumTxnsDSEpoch = function (epoch) {
        return this.provider.send("GetNumTxnsDSEpoch" /* GetNumTxnsDSEpoch */, epoch);
    };
    /**
     * getMinimumGasPrice
     *
     * Gets the numeric minimum gas price
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    Blockchain.prototype.getMinimumGasPrice = function () {
        return this.provider.send("GetMinimumGasPrice" /* GetMinimumGasPrice */);
    };
    /**
     * getPendingTxn
     * See the pending status of transaction
     * @param txId
     */
    Blockchain.prototype.getPendingTxn = function (txId) {
        return this.provider.send("GetPendingTxn" /* GetPendingTxn */, txId.replace('0x', '').toLowerCase());
    };
    /**
     * getBalance
     *
     * Gets the balance of an account by address
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<any, string>>}
     */
    Blockchain.prototype.getBalance = function (addr) {
        var address = util_1.validation.isBech32(addr) ? crypto_1.fromBech32Address(addr) : addr;
        return this.provider.send("GetBalance" /* GetBalance */, address.replace('0x', '').toLowerCase());
    };
    /**
     * getSmartContractCode - returns the smart contract code of a deployed contract.
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<{code: string }, string>>}
     */
    Blockchain.prototype.getSmartContractCode = function (addr) {
        var address = util_1.validation.isBech32(addr) ? crypto_1.fromBech32Address(addr) : addr;
        return this.provider.send("GetSmartContractCode" /* GetSmartContractCode */, address.replace('0x', '').toLowerCase());
    };
    /**
     * getSmartContractInit
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<Value[], string>>}
     */
    Blockchain.prototype.getSmartContractInit = function (addr) {
        var address = util_1.validation.isBech32(addr) ? crypto_1.fromBech32Address(addr) : addr;
        return this.provider.send("GetSmartContractInit" /* GetSmartContractInit */, address.replace('0x', '').toLowerCase());
    };
    /**
     * getSmartContractState - retrieves the entire state of a smart contract
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<any, string>>}
     */
    Blockchain.prototype.getSmartContractState = function (addr) {
        var address = util_1.validation.isBech32(addr) ? crypto_1.fromBech32Address(addr) : addr;
        return this.provider.send("GetSmartContractState" /* GetSmartContractState */, address.replace('0x', '').toLowerCase());
    };
    /**
     * getSmartContractSubState - Queries the contract state, filtered by the variable names.
     * This function is the filtered version of `getSmartContractState`.
     * As `getSubState` performs the filtering, `variableName` of a field is required.
     * If the `subState` is not found, this returns a `null` response.
     *
     * @param {string} address
     * @param { string } variableName - variable name within the state
     * @param { string[] } indices - (optional) If the variable is of map type, you can specify an index (or indices)
     * @returns {Promise<RPCResponse<any, string>>}
     */
    Blockchain.prototype.getSmartContractSubState = function (addr, variableName, indices) {
        var address = util_1.validation.isBech32(addr) ? crypto_1.fromBech32Address(addr) : addr;
        if (!variableName) {
            throw new Error('Variable name required');
        }
        return this.provider.send("GetSmartContractSubState" /* GetSmartContractSubState */, address.replace('0x', '').toLowerCase(), variableName, indices === undefined ? [] : indices);
    };
    /**
     * getSmartContracts
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<Omit<ContractObj, 'init' | 'abi'>, string>>}
     */
    Blockchain.prototype.getSmartContracts = function (addr) {
        var address = util_1.validation.isBech32(addr) ? crypto_1.fromBech32Address(addr) : addr;
        return this.provider.send("GetSmartContracts" /* GetSmartContracts */, address.replace('0x', '').toLowerCase());
    };
    /**
     * getContractAddressFromTransactionID
     *
     * @param {string} txHash
     * @returns {Promise<RPCResponse<string, string>>}
     */
    Blockchain.prototype.getContractAddressFromTransactionID = function (txHash) {
        return this.provider.send("GetContractAddressFromTransactionID" /* GetContractAddressFromTransactionID */, txHash);
    };
    tslib_1.__decorate([
        core_1.sign,
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", [account_1.Transaction, Number, Number, Boolean]),
        tslib_1.__metadata("design:returntype", Promise)
    ], Blockchain.prototype, "createTransaction", null);
    tslib_1.__decorate([
        core_1.sign,
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", [account_1.Transaction]),
        tslib_1.__metadata("design:returntype", Promise)
    ], Blockchain.prototype, "createTransactionWithoutConfirm", null);
    return Blockchain;
}());
exports.Blockchain = Blockchain;
//# sourceMappingURL=chain.js.map