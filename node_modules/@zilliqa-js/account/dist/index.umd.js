(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@zilliqa-js/util'), require('@zilliqa-js/proto'), require('@zilliqa-js/crypto'), require('bip39'), require('hdkey'), require('@zilliqa-js/core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@zilliqa-js/util', '@zilliqa-js/proto', '@zilliqa-js/crypto', 'bip39', 'hdkey', '@zilliqa-js/core'], factory) :
    (factory((global.zjsAccount = {}),global['@zilliqa-js/util'],global['@zilliqa-js/proto'],global['@zilliqa-js/crypto'],global.bip39,global.hdkey,global['@zilliqa-js/core']));
}(this, (function (exports,util,proto,zcrypto,bip39,hdkey,core) { 'use strict';

    bip39 = bip39 && bip39.hasOwnProperty('default') ? bip39['default'] : bip39;
    hdkey = hdkey && hdkey.hasOwnProperty('default') ? hdkey['default'] : hdkey;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    //  This file is part of Zilliqa-Javascript-Library.
    var encodeTransactionProto = function (tx) {
        var msg = {
            version: tx.version,
            nonce: tx.nonce || 0,
            // core protocol Schnorr expects lowercase, non-prefixed address.
            toaddr: util.bytes.hexToByteArray(tx.toAddr.replace('0x', '').toLowerCase()),
            senderpubkey: proto.ZilliqaMessage.ByteArray.create({
                data: util.bytes.hexToByteArray(tx.pubKey || '00'),
            }),
            amount: proto.ZilliqaMessage.ByteArray.create({
                data: Uint8Array.from(tx.amount.toArrayLike(Buffer, undefined, 16)),
            }),
            gasprice: proto.ZilliqaMessage.ByteArray.create({
                data: Uint8Array.from(tx.gasPrice.toArrayLike(Buffer, undefined, 16)),
            }),
            gaslimit: tx.gasLimit,
            code: tx.code && tx.code.length
                ? Uint8Array.from(__spread(tx.code).map(function (c) { return c.charCodeAt(0); }))
                : null,
            data: tx.data && tx.data.length
                ? Uint8Array.from(__spread(tx.data).map(function (c) { return c.charCodeAt(0); }))
                : null,
        };
        var serialised = proto.ZilliqaMessage.ProtoTransactionCoreInfo.create(msg);
        return Buffer.from(proto.ZilliqaMessage.ProtoTransactionCoreInfo.encode(serialised).finish());
    };
    var isTxReceipt = function (x) {
        return util.validation.isPlainObject(x) && util.validation.matchesObject(x, {});
    };
    var isTxParams = function (obj) {
        var validator = {
            version: [util.validation.required(util.validation.isNumber)],
            toAddr: [util.validation.required(util.validation.isAddress)],
            amount: [util.validation.required(util.validation.isBN)],
            gasPrice: [util.validation.required(util.validation.isBN)],
            gasLimit: [util.validation.required(util.validation.isLong)],
            code: [util.validation.isString],
            data: [util.validation.isString],
            receipt: [isTxReceipt],
            nonce: [util.validation.required(util.validation.isNumber)],
            signature: [util.validation.required(util.validation.isSignature)],
        };
        return util.validation.matchesObject(obj, validator);
    };
    var formatOutgoingTx = function (req) {
        if (req.payload.method === "CreateTransaction" /* CreateTransaction */ &&
            isTxParams(req.payload.params[0])) {
            var txConfig = req.payload.params[0];
            var ret = __assign(__assign({}, req), { payload: __assign(__assign({}, req.payload), { params: [
                        __assign(__assign({}, txConfig), { amount: txConfig.amount.toString(), gasLimit: txConfig.gasLimit.toString(), gasPrice: txConfig.gasPrice.toString() }),
                    ] }) });
            return ret;
        }
        return req;
    };
    function sleep(ms) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        setTimeout(function () { return resolve(); }, ms);
                    })];
            });
        });
    }

    var util$1 = /*#__PURE__*/Object.freeze({
        encodeTransactionProto: encodeTransactionProto,
        isTxReceipt: isTxReceipt,
        isTxParams: isTxParams,
        formatOutgoingTx: formatOutgoingTx,
        sleep: sleep
    });

    //  This file is part of Zilliqa-Javascript-Library.
    var Account = /** @class */ (function () {
        function Account(privateKey) {
            this.privateKey = this.normalizePrivateKey(privateKey);
            this.publicKey = zcrypto.getPubKeyFromPrivateKey(this.privateKey);
            this.address = zcrypto.getAddressFromPublicKey(this.publicKey);
            this.bech32Address = zcrypto.toBech32Address(this.address);
        }
        /**
         * fromFile
         *
         * Takes a JSON-encoded keystore and passphrase, returning a fully
         * instantiated Account instance.
         *
         * @param {string} file
         * @param {string} passphrase
         * @returns {Promise<Account>}
         */
        Account.fromFile = function (file, passphrase) {
            return __awaiter(this, void 0, void 0, function () {
                var keystore, privateKey, err_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            keystore = JSON.parse(file);
                            return [4 /*yield*/, zcrypto.decryptPrivateKey(passphrase, keystore)];
                        case 1:
                            privateKey = _a.sent();
                            return [2 /*return*/, new Account(privateKey)];
                        case 2:
                            err_1 = _a.sent();
                            throw new Error("Could not decrypt keystore file.");
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * toFile
         *
         * @param {string} passphrase
         * @param {kdf} 'pbkdf2' | 'scrypt'
         * @returns {Promise<string>}
         */
        Account.prototype.toFile = function (passphrase, kdf) {
            if (kdf === void 0) { kdf = 'scrypt'; }
            return __awaiter(this, void 0, void 0, function () {
                var keystore;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!passphrase || !passphrase.length) {
                                throw new Error('Passphrase cannot have a length of 0');
                            }
                            return [4 /*yield*/, zcrypto.encryptPrivateKey(kdf, this.privateKey, passphrase)];
                        case 1:
                            keystore = _a.sent();
                            return [2 /*return*/, keystore];
                    }
                });
            });
        };
        /**
         * signTransaction
         *
         * @param {Buffer} bytes - the data to be signed
         *
         * @returns {string} - the hex encoded signature. it is a concatenation of
         * the r and s values in hex, each padded to a length of 64.
         */
        Account.prototype.signTransaction = function (bytes) {
            return zcrypto.sign(bytes, this.privateKey, this.publicKey);
        };
        Account.prototype.normalizePrivateKey = function (privateKey) {
            return zcrypto.normalizePrivateKey(privateKey);
        };
        return Account;
    }());

    //  This file is part of Zilliqa-Javascript-Library.
    var Wallet = /** @class */ (function (_super) {
        __extends(Wallet, _super);
        /**
         * constructor
         *
         * Takes an array of Account objects and instantiates a Wallet instance.
         *
         * @param {Account[]} accounts
         */
        function Wallet(provider, accounts) {
            if (accounts === void 0) { accounts = []; }
            var _this = _super.call(this) || this;
            _this.accounts = {};
            if (accounts.length) {
                _this.accounts = accounts.reduce(function (acc, account) {
                    var _a;
                    return __assign(__assign({}, acc), (_a = {}, _a[account.address] = account, _a));
                }, {});
            }
            _this.provider = provider;
            _this.defaultAccount = accounts[0];
            return _this;
        }
        /**
         * create
         *
         * Creates a new keypair with a randomly-generated private key. The new
         * account is accessible by address.
         *
         * @returns {string} - address of the new account
         */
        Wallet.prototype.create = function () {
            var _a;
            var privateKey = zcrypto.schnorr.generatePrivateKey();
            var newAccount = new Account(privateKey);
            this.accounts = __assign(__assign({}, this.accounts), (_a = {}, _a[newAccount.address] = newAccount, _a));
            if (!this.defaultAccount) {
                this.defaultAccount = newAccount;
            }
            return newAccount.address;
        };
        /**
         * addByPrivateKey
         *
         * Adds an account to the wallet by private key.
         *
         * @param {string} privateKey - hex-encoded private key
         * @returns {string} - the corresponing address, computer from the private
         * key.
         */
        Wallet.prototype.addByPrivateKey = function (privateKey) {
            var _a;
            var newAccount = new Account(privateKey);
            this.accounts = __assign(__assign({}, this.accounts), (_a = {}, _a[newAccount.address] = newAccount, _a));
            if (!this.defaultAccount) {
                this.defaultAccount = newAccount;
            }
            return newAccount.address;
        };
        /**
         * addByKeystore
         *
         * Adds an account by keystore. This method is asynchronous and returns
         * a Promise<string>, in order not to block on the underlying decryption
         * operation.
         *
         * @param {string} keystore
         * @param {string} passphrase
         * @returns {Promise<string>}
         */
        Wallet.prototype.addByKeystore = function (keystore, passphrase) {
            return __awaiter(this, void 0, void 0, function () {
                var newAccount;
                var _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, Account.fromFile(keystore, passphrase)];
                        case 1:
                            newAccount = _b.sent();
                            this.accounts = __assign(__assign({}, this.accounts), (_a = {}, _a[newAccount.address] = newAccount, _a));
                            if (!this.defaultAccount) {
                                this.defaultAccount = newAccount;
                            }
                            return [2 /*return*/, newAccount.address];
                    }
                });
            });
        };
        /**
         * addByMnemonic
         *
         * Adds an `Account` by use of a mnemonic as specified in BIP-32 and BIP-39
         *
         * @param {string} phrase - 12-word mnemonic phrase
         * @param {number} index=0 - the number of the child key to add
         * @returns {string} - the corresponding address
         */
        Wallet.prototype.addByMnemonic = function (phrase, index) {
            if (index === void 0) { index = 0; }
            if (!this.isValidMnemonic(phrase)) {
                throw new Error("Invalid mnemonic phrase: " + phrase);
            }
            var seed = bip39.mnemonicToSeed(phrase);
            var hdKey = hdkey.fromMasterSeed(seed);
            var childKey = hdKey.derive("m/44'/313'/0'/0/" + index);
            var privateKey = childKey.privateKey.toString('hex');
            return this.addByPrivateKey(privateKey);
        };
        /**
         * export
         *
         * Exports the specified account as a keystore file.
         *
         * @param {string} address
         * @param {string} passphrase
         * @param {KDF} kdf='scrypt'
         * @returns {Promise<string>}
         */
        Wallet.prototype.export = function (address, passphrase, kdf) {
            if (kdf === void 0) { kdf = 'scrypt'; }
            if (!this.accounts[address]) {
                throw new Error("No account with address " + address + " exists");
            }
            return this.accounts[address].toFile(passphrase, kdf);
        };
        /**
         * remove
         *
         * Removes an account from the wallet and returns boolean to indicate
         * failure or success.
         *
         * @param {string} address
         * @returns {boolean}
         */
        Wallet.prototype.remove = function (address) {
            if (this.accounts[address]) {
                var _a = this.accounts, _b = address, toRemove = _a[_b], rest = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
                this.accounts = rest;
                return true;
            }
            return false;
        };
        /**
         * setDefault
         *
         * Sets the default account of the wallet.
         *
         * @param {string} address
         */
        Wallet.prototype.setDefault = function (address) {
            this.defaultAccount = this.accounts[address];
        };
        /**
         * sign
         *
         * signs an unsigned transaction with the default account.
         *
         * @param {Transaction} tx
         * @param {string} account
         * @returns {Transaction}
         */
        Wallet.prototype.sign = function (tx) {
            if (tx.txParams && tx.txParams.pubKey) {
                // attempt to find the address
                var senderAddress = zcrypto.getAddressFromPublicKey(tx.txParams.pubKey);
                if (!this.accounts[senderAddress]) {
                    throw new Error("Could not sign the transaction with " + senderAddress + " as it does not exist");
                }
                return this.signWith(tx, senderAddress);
            }
            if (!this.defaultAccount) {
                throw new Error('This wallet has no default account.');
            }
            return this.signWith(tx, this.defaultAccount.address);
        };
        /**
         * signWith
         *
         * @param {Transaction} tx
         * @param {string} account
         * @returns {Transaction}
         */
        Wallet.prototype.signWith = function (tx, account) {
            return __awaiter(this, void 0, void 0, function () {
                var signer_1, balance_1, withNonce_1, err_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.accounts[account]) {
                                throw new Error('The selected account does not exist on this Wallet instance.');
                            }
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 4, , 5]);
                            signer_1 = this.accounts[account];
                            if (!!tx.txParams.nonce) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.provider.send('GetBalance', signer_1.address.replace('0x', '').toLowerCase())];
                        case 2:
                            balance_1 = _a.sent();
                            if (typeof balance_1.result.nonce !== 'number') {
                                throw new Error('Could not get nonce');
                            }
                            withNonce_1 = tx.map(function (txObj) {
                                return __assign(__assign({}, txObj), { nonce: txObj.nonce || balance_1.result.nonce + 1, pubKey: signer_1.publicKey });
                            });
                            return [2 /*return*/, withNonce_1.map(function (txObj) {
                                    // @ts-ignore
                                    return __assign(__assign({}, txObj), { signature: signer_1.signTransaction(withNonce_1.bytes) });
                                })];
                        case 3: return [2 /*return*/, tx.map(function (txObj) {
                                return __assign(__assign({}, txObj), { signature: signer_1.signTransaction(tx.bytes) });
                            })];
                        case 4:
                            err_1 = _a.sent();
                            throw err_1;
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        Wallet.prototype.isValidMnemonic = function (phrase) {
            if (phrase.trim().split(/\s+/g).length < 12) {
                return false;
            }
            return bip39.validateMnemonic(phrase);
        };
        return Wallet;
    }(core.Signer));

    //  This file is part of Zilliqa-Javascript-Library.
    /**
     * Transaction
     *
     * Transaction is a functor. Its purpose is to encode the possible states a
     * Transaction can be in:  Confirmed, Rejected, Pending, or Initialised (i.e., not broadcasted).
     */
    var Transaction = /** @class */ (function () {
        function Transaction(params, provider, status, toDS) {
            if (status === void 0) { status = 0 /* Initialised */; }
            if (toDS === void 0) { toDS = false; }
            this.code = '';
            this.data = '';
            // private members
            this.version = params.version;
            this.toAddr = zcrypto.normaliseAddress(params.toAddr);
            this.nonce = params.nonce;
            this.pubKey = params.pubKey;
            this.amount = params.amount;
            this.code = params.code || '';
            this.data = params.data || '';
            this.signature = params.signature;
            this.gasPrice = params.gasPrice;
            this.gasLimit = params.gasLimit;
            this.receipt = params.receipt;
            // public members
            this.provider = provider;
            this.status = status;
            this.toDS = toDS;
            this.blockConfirmation = 0;
            this.eventEmitter = new core.EventEmitter();
        }
        /**
         * confirm
         *
         * constructs an already-confirmed transaction.
         *
         * @static
         * @param {BaseTx} params
         */
        Transaction.confirm = function (params, provider) {
            return new Transaction(params, provider, 2 /* Confirmed */);
        };
        /**
         * reject
         *
         * constructs an already-rejected transaction.
         *
         * @static
         * @param {BaseTx} params
         */
        Transaction.reject = function (params, provider) {
            return new Transaction(params, provider, 3 /* Rejected */);
        };
        Object.defineProperty(Transaction.prototype, "bytes", {
            get: function () {
                return encodeTransactionProto(this.txParams);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transaction.prototype, "senderAddress", {
            get: function () {
                if (!this.pubKey) {
                    return '0'.repeat(40);
                }
                return zcrypto.getAddressFromPublicKey(this.pubKey);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transaction.prototype, "txParams", {
            get: function () {
                return {
                    version: this.version,
                    toAddr: zcrypto.normaliseAddress(this.toAddr),
                    nonce: this.nonce,
                    pubKey: this.pubKey,
                    amount: this.amount,
                    gasPrice: this.gasPrice,
                    gasLimit: this.gasLimit,
                    code: this.code,
                    data: this.data,
                    signature: this.signature,
                    receipt: this.receipt,
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transaction.prototype, "payload", {
            get: function () {
                return {
                    version: 0,
                    toAddr: this.toAddr,
                    nonce: this.nonce,
                    pubKey: this.pubKey,
                    amount: this.amount.toString(),
                    gasPrice: this.gasPrice.toString(),
                    gasLimit: this.gasLimit.toString(),
                    code: this.code,
                    data: this.data,
                    signature: this.signature,
                    receipt: this.receipt,
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * isPending
         *
         * @returns {boolean}
         */
        Transaction.prototype.isPending = function () {
            return this.status === 1 /* Pending */;
        };
        /**
         * isInitialised
         *
         * @returns {boolean}
         */
        Transaction.prototype.isInitialised = function () {
            return this.status === 0 /* Initialised */;
        };
        Transaction.prototype.getReceipt = function () {
            return this.receipt;
        };
        /**
         * isConfirmed
         *
         * @returns {boolean}
         */
        Transaction.prototype.isConfirmed = function () {
            return this.status === 2 /* Confirmed */;
        };
        /**
         * isRejected
         *
         * @returns {boolean}
         */
        Transaction.prototype.isRejected = function () {
            return this.status === 3 /* Rejected */;
        };
        /**
         * setProvider
         *
         * Sets the provider on this instance.
         *
         * @param {Provider} provider
         */
        Transaction.prototype.setProvider = function (provider) {
            this.provider = provider;
        };
        /**
         * setStatus
         *
         * Escape hatch to imperatively set the state of the transaction.
         *
         * @param {TxStatus} status
         * @returns {undefined}
         */
        Transaction.prototype.setStatus = function (status) {
            this.status = status;
            return this;
        };
        Transaction.prototype.observed = function () {
            return this.eventEmitter;
        };
        /**
         * blockConfirm
         *
         * Use `RPCMethod.GetLatestBlock` to get latest blockNumber
         * Use interval to get the latestBlockNumber
         * After BlockNumber change, then we use `RPCMethod.GetTransaction` to get the receipt
         *
         * @param {string} txHash
         * @param {number} maxblockCount
         * @param {number} interval interval in milliseconds
         * @returns {Promise<Transaction>}
         */
        Transaction.prototype.blockConfirm = function (txHash, maxblockCount, interval) {
            if (maxblockCount === void 0) { maxblockCount = 4; }
            if (interval === void 0) { interval = 1000; }
            return __awaiter(this, void 0, void 0, function () {
                var blockStart, blockChecked, attempt, blockLatest, blockNext, err_1, blockFailed, errorMessage;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.status = 1 /* Pending */;
                            return [4 /*yield*/, this.getBlockNumber()];
                        case 1:
                            blockStart = _a.sent();
                            blockChecked = blockStart;
                            attempt = 0;
                            _a.label = 2;
                        case 2:
                            if (!(attempt < maxblockCount)) return [3 /*break*/, 12];
                            _a.label = 3;
                        case 3:
                            _a.trys.push([3, 8, , 9]);
                            return [4 /*yield*/, this.getBlockNumber()];
                        case 4:
                            blockLatest = _a.sent();
                            blockNext = blockChecked.add(new util.BN(attempt === 0 ? attempt : 1));
                            if (!blockLatest.gte(blockNext)) return [3 /*break*/, 6];
                            blockChecked = blockLatest;
                            this.emit("track" /* Track */, {
                                txHash: txHash,
                                attempt: attempt,
                                currentBlock: blockChecked.toString(),
                            });
                            return [4 /*yield*/, this.trackTx(txHash)];
                        case 5:
                            if (_a.sent()) {
                                this.blockConfirmation = blockLatest.sub(blockStart).toNumber();
                                return [2 /*return*/, this];
                            }
                            return [3 /*break*/, 7];
                        case 6:
                            attempt = attempt - 1 >= 0 ? attempt - 1 : 0;
                            _a.label = 7;
                        case 7: return [3 /*break*/, 9];
                        case 8:
                            err_1 = _a.sent();
                            this.status = 3 /* Rejected */;
                            throw err_1;
                        case 9:
                            if (!(attempt + 1 < maxblockCount)) return [3 /*break*/, 11];
                            return [4 /*yield*/, sleep(interval)];
                        case 10:
                            _a.sent();
                            _a.label = 11;
                        case 11:
                            attempt += 1;
                            return [3 /*break*/, 2];
                        case 12: return [4 /*yield*/, this.getBlockNumber()];
                        case 13:
                            blockFailed = _a.sent();
                            this.blockConfirmation = blockFailed.sub(blockStart).toNumber();
                            this.status = 3 /* Rejected */;
                            errorMessage = "The transaction is still not confirmed after " + maxblockCount + " blocks.";
                            throw new Error(errorMessage);
                    }
                });
            });
        };
        /**
         * confirmReceipt
         *
         * Similar to the Promise API. This sets the Transaction instance to a state
         * of pending. Calling this function kicks off a passive loop that polls the
         * lookup node for confirmation on the txHash.
         *
         * The polls are performed with a linear backoff:
         *
         * `const delay = interval * attempt`
         *
         * This is a low-level method that you should generally not have to use
         * directly.
         *
         * @param {string} txHash
         * @param {number} maxAttempts
         * @param {number} initial interval in milliseconds
         * @returns {Promise<Transaction>}
         */
        Transaction.prototype.confirm = function (txHash, maxAttempts, interval) {
            if (maxAttempts === void 0) { maxAttempts = core.GET_TX_ATTEMPTS; }
            if (interval === void 0) { interval = 1000; }
            return __awaiter(this, void 0, void 0, function () {
                var attempt, err_2, errorMessage;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.status = 1 /* Pending */;
                            attempt = 0;
                            _a.label = 1;
                        case 1:
                            if (!(attempt < maxAttempts)) return [3 /*break*/, 8];
                            this.emit("track" /* Track */, {
                                txHash: txHash,
                                attempt: attempt,
                            });
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 4, , 5]);
                            return [4 /*yield*/, this.trackTx(txHash)];
                        case 3:
                            if (_a.sent()) {
                                return [2 /*return*/, this];
                            }
                            return [3 /*break*/, 5];
                        case 4:
                            err_2 = _a.sent();
                            this.status = 3 /* Rejected */;
                            throw err_2;
                        case 5:
                            if (!(attempt + 1 < maxAttempts)) return [3 /*break*/, 7];
                            return [4 /*yield*/, sleep(interval * attempt)];
                        case 6:
                            _a.sent();
                            _a.label = 7;
                        case 7:
                            attempt++;
                            return [3 /*break*/, 1];
                        case 8:
                            this.status = 3 /* Rejected */;
                            errorMessage = "The transaction is still not confirmed after " + maxAttempts + " attempts.";
                            throw new Error(errorMessage);
                    }
                });
            });
        };
        /**
         * map
         *
         * maps over the transaction, allowing for manipulation.
         *
         * @param {(prev: TxParams) => TxParams} fn - mapper
         * @returns {Transaction}
         */
        Transaction.prototype.map = function (fn) {
            var newParams = fn(this.txParams);
            this.setParams(newParams);
            return this;
        };
        Transaction.prototype.setParams = function (params) {
            this.version = params.version;
            this.toAddr = zcrypto.normaliseAddress(params.toAddr);
            this.nonce = params.nonce;
            this.pubKey = params.pubKey;
            this.amount = params.amount;
            this.code = params.code || '';
            this.data = params.data || '';
            this.signature = params.signature;
            this.gasPrice = params.gasPrice;
            this.gasLimit = params.gasLimit;
            this.receipt = params.receipt;
        };
        Transaction.prototype.trackTx = function (txHash) {
            return __awaiter(this, void 0, void 0, function () {
                var res;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.provider.send("GetTransaction" /* GetTransaction */, txHash)];
                        case 1:
                            res = _a.sent();
                            if (res.error) {
                                this.emit("error" /* Error */, res.error);
                                return [2 /*return*/, false];
                            }
                            this.id = res.result.ID;
                            this.receipt = __assign(__assign({}, res.result.receipt), { cumulative_gas: parseInt(res.result.receipt.cumulative_gas, 10) });
                            this.emit("receipt" /* Receipt */, this.receipt);
                            this.status =
                                this.receipt && this.receipt.success
                                    ? 2 /* Confirmed */
                                    : 3 /* Rejected */;
                            return [2 /*return*/, true];
                    }
                });
            });
        };
        Transaction.prototype.getBlockNumber = function () {
            return __awaiter(this, void 0, void 0, function () {
                var res, error_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, this.provider.send("GetLatestTxBlock" /* GetLatestTxBlock */)];
                        case 1:
                            res = _a.sent();
                            if (res.error === undefined && res.result.header.BlockNum) {
                                // if blockNumber is too high, we use BN to be safer
                                return [2 /*return*/, new util.BN(res.result.header.BlockNum)];
                            }
                            else {
                                throw new Error('Can not get latest BlockNumber');
                            }
                            return [3 /*break*/, 3];
                        case 2:
                            error_1 = _a.sent();
                            throw error_1;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        Transaction.prototype.emit = function (event, txEvent) {
            this.eventEmitter.emit(event, __assign(__assign({}, txEvent), { event: event }));
        };
        return Transaction;
    }());

    //  This file is part of Zilliqa-Javascript-Library.
    var TransactionFactory = /** @class */ (function () {
        function TransactionFactory(provider, signer) {
            this.provider = provider;
            this.provider.middleware.request.use(formatOutgoingTx, "CreateTransaction" /* CreateTransaction */);
            this.signer = signer;
        }
        TransactionFactory.prototype.new = function (txParams, toDs) {
            if (toDs === void 0) { toDs = false; }
            return new Transaction(txParams, this.provider, 0 /* Initialised */, toDs);
        };
        return TransactionFactory;
    }());

    //  This file is part of Zilliqa-Javascript-Library.
    (function (TxStatus) {
        TxStatus[TxStatus["Initialised"] = 0] = "Initialised";
        TxStatus[TxStatus["Pending"] = 1] = "Pending";
        TxStatus[TxStatus["Confirmed"] = 2] = "Confirmed";
        TxStatus[TxStatus["Rejected"] = 3] = "Rejected";
    })(exports.TxStatus || (exports.TxStatus = {}));
    (function (TxEventName) {
        TxEventName["Error"] = "error";
        TxEventName["Receipt"] = "receipt";
        TxEventName["Track"] = "track";
    })(exports.TxEventName || (exports.TxEventName = {}));

    //  This file is part of Zilliqa-Javascript-Library.

    exports.util = util$1;
    exports.Account = Account;
    exports.Wallet = Wallet;
    exports.Transaction = Transaction;
    exports.TransactionFactory = TransactionFactory;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
