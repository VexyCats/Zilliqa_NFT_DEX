scilla_version 0
(* Internal Getters *)
(* ARE ANY OF THESE POSSIBLE to be internal? *)
(* index of listing in mapping?
 function _indexByListingId (bytes32 listingId)
    internal view returns (uint256)
  {
    return listingIdToIndex[listingId];
  }
    returns the listing information
  function _listingByListingId (bytes32 listingId)
    internal view returns (Listing memory)
  {
    return listings[_indexByListingId(listingId)];
  }
        checks if exists
  function _listingIdExists (bytes32 listingId)
    internal view returns (bool)
  {
    Listing memory listing = _listingByListingId(listingId);
    return (listing.owner != address(0));
  }
  *)
  (* Checks if there is a fee attached to the transaction
  function _hasFeeValue(uint256 fee)
    internal view
  returns (bool) {
    return msg.value >= fee;
  }
  *)
(* Getters *)
 (*getListing
  function getListing(bytes32 listingId)
    public view returns(address, address, uint256, uint256, uint256, uint256)
  {
    Listing memory listing = _listingByListingId(listingId);
    return (listing.owner, listing.tokenAddress, listing.tokenId, listing.paymentAmount, listing.timeAdded, uint256(listing.listState));
  }*)
 (* 
  function _buy (address _buyer, bytes32 _listingId)
  internal
{
  Listing memory listing = _listingByListingId(_listingId);

  listing.listState = ListStates.COMPLETED;
  _transferEth(listing.owner, listing.paymentAmount);
  _transferFrom(listing.tokenAddress, address(this), _buyer, listing.tokenId);

  emit ListingCompleted(_listingId, _buyer);
}


function _purchase (address _buyer, bytes32 _listingId, uint256 _fee)
  internal
{
  require(_listingIdExists(_listingId), NOT_EXISTS_ERROR);

  Listing memory listing = _listingByListingId(_listingId);

  require(listing.listState == ListStates.ACTIVE, ACTION_ERROR);
  require(_hasFeeValue(_fee.add(listing.paymentAmount)), PAYMENT_ERROR);

  _buy(_buyer, _listingId);
}*)
  (* Logic transfers *)
  (* _transferZil from this contract to seller after bought *)
  (*
    function _transferZil (address _recipient, uint256 _amount)
    internal
  {
    address(_recipient).transfer(_amount);
  }
    
     transfer NFT to buyer after the sell is complete 
    
  function _transferFrom (address _token, address _owner, address _recipient, uint256 _tokenId)
    internal
  {
    IERC721(_token).transferFrom(_owner, _recipient, _tokenId);
  }
  *)
  
  (*
  
  MAIN ORDER LOGIC EXCHANGE *)
  
   (*_purchase called with amount and listing id to buy and then confirms
   info and completes the sell
   
    function _purchase (address _buyer, bytes32 _listingId, uint256 _fee)
    internal
  {
    require(_listingIdExists(_listingId), NOT_EXISTS_ERROR);

    Listing memory listing = _listingByListingId(_listingId);

    require(listing.listState == ListStates.ACTIVE, ACTION_ERROR);
    require(_hasFeeValue(_fee.add(listing.paymentAmount)), PAYMENT_ERROR);

    _buy(_buyer, _listingId);
  }

  function _trade (address _seller, bytes32 _listingId, address _tokenAddress, uint256 _tokenId, uint256 _paymentAmount, uint256 _fee)
    internal
  {
    require(!_listingIdExists(_listingId), EXISTS_ERROR);
    require(_hasFeeValue(_fee), PAYMENT_ERROR);

    _sell(_seller, _listingId, _tokenAddress, _tokenId, _paymentAmount);
  }

  function _cancel (address _seller, bytes32 _listingId)
    internal
  {
    Listing memory listing = _listingByListingId(_listingId);
    require(listing.owner == _seller, PERMISSION_ERROR);
    require(listing.listState == ListStates.ACTIVE, ACTION_ERROR);

    listing.listState = ListStates.CANCELLED;
    _transferFrom(listing.tokenAddress, address(this), listing.owner, listing.tokenId);

    emit ListingRemoved(_listingId);
  }

  function _suspend (address _admin, bytes32 listingId)
    internal
  {
    require(_isAdmin(_admin), PERMISSION_ERROR);
    Listing memory listing = _listingByListingId(listingId);
    require(listing.listState == ListStates.ACTIVE, ACTION_ERROR);
    listing.listState = ListStates.SUSPENDED;

    emit ListingSuspended(listingId);
  }
   // SETTERS
 /**
  * @dev Sets the storage contract for storing data
  * @return  bool true or false
  */
  function setSigner(address _addr) public onlyOwner  returns (bool){
      return _setSigner(_addr);
  }

  function purchase (bytes32 listingId, uint256 fee, bytes signature )
    payable public
  {
      require(_isValidPurchaseSignature(msg.sender, listingId, fee, signature), SIGNATURE_ERROR);
      _purchase(msg.sender, listingId, fee);
  }

  function purchaseFor (address buyer, bytes32 listingId, uint256 fee, bytes signature )
    payable public
  {
      require(_isValidPurchaseSignature(buyer, listingId, fee, signature), SIGNATURE_ERROR);
      _purchase(buyer, listingId, fee);
  }

  function trade (bytes32 listingId, address token, uint256 tokenId, uint256 paymentAmount, uint256 fee, bytes signature )
    public
  {
    require(_isValidTradeSignature(msg.sender, listingId, token, tokenId, paymentAmount, fee, signature), SIGNATURE_ERROR);
    _trade(msg.sender, listingId, token, tokenId,  paymentAmount, fee);
  }

  function tradeFor (address _seller, bytes32 listingId, address token, uint256 tokenId, uint256 paymentAmount, uint256 fee, bytes signature )
    public
  {
    require(_isValidTradeSignature(_seller, listingId, token, tokenId, paymentAmount, fee, signature), SIGNATURE_ERROR);
    _trade(_seller, listingId, token, tokenId,  paymentAmount, fee);
  }

  function cancelTrade (bytes32 _listingId)
    public
  {
    _cancel(msg.sender, _listingId);
  }

  *)
  
(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils ListUtils

library NFT

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
Cons {Message} msg nil_msg

(* Checks and see if an address is a contract owner *)
let checkContractOwner =
    fun (msgSender: ByStr20) => 
    fun (contractOwner: ByStr20) =>
        builtin eq msgSender contractOwner

type ListState =
| ListState of String

(*
ByStr20 - Address of owner
Uint256 - price
ByStr20 - address of contract 
Uint256 - token id
Uint256 listingID
*)
 type Order =
| Order of ByStr20 Uint256 ByStr20 Uint256 Uint256 ListState 

(* Error events *)
let makeErrorEvent =
    fun (location: String) =>
    fun (errorCode: Uint32) =>
        {_eventname: "Error"; raisedAt: location; code: errorCode }

(* Error codes *)
(*         string constant public version = "Mintable v0.6" ;
  string constant private NOT_EXISTS_ERROR = 'Listing not found';
  string constant private EXISTS_ERROR = 'Listing already exists';
  string constant private PAYMENT_ERROR = 'Transaction value Insufficient';
  string constant private PERMISSION_ERROR = 'You do not have permission for action';
  string constant private SIGNATURE_ERROR = 'Provided details could not be authenticated';
  string constant private TRANSFER_ERROR = 'Token transfer not successful';
  string constant private DEFINED_ERROR = 'Variable already set';
  string constant private ACTION_ERROR = 'Action impossible at this time'; *)
let code_success = Uint32 0
let code_failure = Uint32 1
let code_not_authorized = Uint32 2
let code_not_found = Uint32 4
let code_bad_request = Uint32 5
let code_token_exists = Uint32 6
let code_unexpected_error = Uint32 9


(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract NFTDEX
(contractOwner : ByStr20)

(* mutable fields *)

(* Orderbook: mapping (orderIds => ( (tokenA, valueA) (tokenB, valueB) )) *)
(* @param: tokenA: Contract address of token A *)
(* @param: valueA: total units of token A offered by maker *)
(* @param: tokenB: Contract address of token B *)
(* @param: valueB: total units of token B requsted by maker *)
field orderbook : Map Uint256 Order
                  = Emp Uint256 Order
(* Order info stores the mapping ( orderId => (tokenOwnerAddress, expirationBlock)) *)
field orderIDtoOrder : Map ByStr32 (Pair (ByStr20)(BNum)) = Emp ByStr32 (Pair (ByStr20) (BNum))
(* Mapping between owner and all their orders *)
field orderOwnerMap: Map ByStr20 List = Emp ByStr20 List
(* Mapping from owner to number of owned tokens *)
field ownedOrdersCount: Map ByStr20 Uint256 = Emp ByStr20 Uint256

(* Mapping between tokenId to approved address *)
(* @dev: There can only be one approved address per token at a given time. *)
field tokenApprovals: Map ByStr20 (Map Uint256 Bool)  = Emp  ByStr20 (Map Uint256 Bool)

(* Mapping from owner to operator approvals  *)
field operatorApprovals: Map ByStr20 (Map ByStr20 Bool) 
                            = Emp ByStr20 (Map ByStr20 Bool)
(* immutable field *)


(* Prceedures *)
procedure checkApproved (contractAddress: ByStr20, tokenID: Uint256)
     e = { _eventname : "Sender for approval check is: "; msgsender: _sender};
        event e;
  self_DEX = _this_address;
  zero = Uint128 0;
    isApprovedCall = {_tag: "CheckApproval";
    _recipient: contractAddress;
    _amount: zero;
    from: _sender;
    to: self_DEX;
    tokenID: tokenID;
    callback: "approved"
    };
    msgs = one_msg isApprovedCall;
    send msgs

end

(* @dev Transfer the ownership of a given token ID to another address

@param contractAddress - address of NFT contract
@param tokenID - address of NFT contract

calling: transition transferFrom(from: ByStr20, to: ByStr20, tokenId: Uint256)
*)
procedure transferNFTtoDEX (contractAddress: ByStr20, tokenID: Uint256)
(* take params and make a call to transfer NFT to self.*)
 self_DEX = _this_address;
  zero = Uint128 0;
    transfered = {_tag: "transferFromWithCallback";
    _recipient: contractAddress;
    _amount: zero;
    from: _sender;
    to: self_DEX;
    tokenID: tokenID
    };
    msgs = one_msg transfered;
    e = { _eventname : "Transfer NFT"; tokenID: tokenID};
event e;
    send msgs
end
(*Transitions*)


  
transition getListing (listingID: Uint256)
end




transition approved (tokenId: Uint256, owner: ByStr20, contractAddress: ByStr20, approvedTo: ByStr20, approval: Bool)
(* called back from NFT contract if approved*)
 is_sender = builtin eq contractAddress _sender;
match is_sender with
|True =>
    (*continue logic for selling*)
  
|False =>
e = let raisedAt = "code_not_authorized" in makeErrorEvent raisedAt code_not_authorized;
event e
end;
(*make sure msg.sender is from the contract address of NFT to prevent malicious*)
(* check bool for approval*)
match approval with
| True =>
(* save owner and id in mapping*)
tokenApprovals[contractAddress][tokenId] := approval;
(*call the transfer function and continue selling NFT*)
transferNFTtoDEX contractAddress tokenId
| False =>
    end
end


  (* Create a listing and sell an NFT
  
   function _sell (address _seller, bytes32 _listingId, address _tokenAddress, uint256 _tokenId, uint256 _paymentAmount)
  internal
{
  //Take token ownership
  _transferFrom(_tokenAddress, msg.sender, address(this), _tokenId);
  require(IERC721(_tokenAddress).ownerOf(_tokenId) == address(this), TRANSFER_ERROR);

  uint256 index = listings.length;
  Listing memory listing = Listing(_seller, _tokenAddress, _tokenId, _paymentAmount, block.timestamp, ListStates.ACTIVE);
  listings.push(listing);
  listingIdToIndex[_listingId] = index;

  emit ListingAdded(msg.sender, _listingId, index);
}
*)

(* First call from frontend. User wants to post an item for sale. They call this function
then it will check if approval is okay, if so, then it will transfer 721 to itself,
and create the listing information and publish it as an item for sale *)
transition sell (contractAddress: ByStr20, tokenID: Uint256, price: Uint256)    
    (* Check approval to see if we can transfer*)
   checkApproved contractAddress tokenID; 
   
   (* get variables *)
    orderbook <- orderbook;
    state = "ACTIVE";
    liststate = ListState state; 

    (* get length of listings mapping for listingid *)
    (* use global variable to track order numbers*)
    temp_length = builtin size orderbook;
    listingID = builtin to_uint256 temp_length;
    (* take listing id and start creating listing*)
    match listingID with
    |Some listingid =>
        (* creating listing and storing in listing mappings*)
    newOrder = Order _sender price contractAddress tokenID listingid liststate;
    order <- orderbook[listingid]; 
    (* Store listing info inside the owners mappings and other mappings for references *)
      match order with
        | Some (Order owner price contractaddress tokenID listingid liststate)  => 
            (* fire off events *)
          
         e = {_eventname : "test"; extracted_owner : owner};
        event e
       (* _ is global catch all *)
        | _ =>
            (* Something went wrong *)
         e = {_eventname : "Error1" };
            event e
        end
    | None =>
         e = {_eventname : "Error1" };
            event e
     end
       
  
end
    

  
     
      
    (* Create a listing and sell an NFT*)  
transition purchase (orderID: ByStr20, tokenID: Uint256, price: Uint256)    
end
(* Get the owner of a particular tokenId *)
transition ownerOf(listingID: Uint256) 
    order <- orderbook[listingID];
      e = { _eventname : "OwnerOfListing"; order: order; listingid:  listingID};
      event e
   
end









