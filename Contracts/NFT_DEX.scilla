scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils ListUtils

library NFT

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
Cons {Message} msg nil_msg

        
let checkOrderStatus = 
    fun (orderStatus: String) =>
    fun (requiredStatus: String) =>
        builtin eq orderStatus requiredStatus



(*ByStr20 - Address of owner*)
(*Uint256 - price*)
(*ByStr20 - address of contract *)
(*Uint256 - token id*)
(*Uint256 listingID*)

 type Order =
| Order of ByStr20 Uint128 ByStr20 Uint256 Uint256 String 

(* Error events *)
let makeErrorEvent =
    fun (location: String) =>
    fun (errorCode: Uint32) =>
        {_eventname: "Error"; raisedAt: location; code: errorCode }

(* Error codes *)

let code_success = Uint32 0
let code_failure = Uint32 1
let code_not_authorized = Uint32 2
let order_not_found = Uint32 4
let code_bad_request = Uint32 5
let code_token_exists = Uint32 6
let payment_amount_error = Uint32 7
let code_unexpected_error = Uint32 9


(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract NFTDEX
(contractOwner : ByStr20,
one : Uint256)

(* mutable fields *)
(*Order IDs - use global variable to track order numbers *)
field orderID : Uint256 = Uint256 0
(* Orderbook: mapping (orderId => ( Order struct ) *)

field orderbook : Map Uint256 Order
                  = Emp Uint256 Order
field temp_orderbook : Map ByStr20 (Map Uint256 Order)
                            = Emp ByStr20 (Map Uint256 Order)         

(* Mapping between owner and all their orders *)
field orderOwnerList: Map ByStr20 List = Emp ByStr20 List
(* Fee taken from each purchase, 10% of price *)
field dexFee: Uint128 = Uint128 10


(* Prceedures *)
procedure checkApproved (contractAddress: ByStr20, tokenID: Uint256)
     e = { _eventname : "Sender for approval check is: "; msgsender: _sender};
        event e;
  self_DEX = _this_address;
  zero = Uint128 0;
    isApprovedCall = {_tag: "getApproved";
    _recipient: contractAddress;
    _amount: zero;
    tokenID: tokenID
    };
    msgs = one_msg isApprovedCall;
    send msgs

end

(* @dev Transfer the ownership of a given token ID to another address*)

(*@param contractAddress - address of NFT contract*)
(*@param tokenID - address of NFT contract*)
procedure transferNFTtoOwner (contractAddress: ByStr20, tokenID: Uint256, owner: ByStr20)
  zero = Uint128 0;
    transfered = {_tag: "transfer";
    _recipient: contractAddress;
    _amount: zero;
    to: owner;
    tokenID: tokenID
        };
    msgs = one_msg transfered;
    e = { _eventname : "Transfer NFT back to person"; tokenID: tokenID};
    event e;
    send msgs
end
(* @dev Transfer the ownership of a given token ID to this address*)

(*@param contractAddress - address of NFT contract*)
(*@param tokenID - address of NFT contract*)
procedure transferNFTtoDEX (contractAddress: ByStr20, tokenID: Uint256)
(* take params and make a call to transfer NFT to self.*)
 self_DEX = _this_address;
  zero = Uint128 0;
    transfered = {_tag: "transferFrom";
    _recipient: contractAddress;
    _amount: zero;
    from: _sender;
    to: self_DEX;
    tokenID: tokenID
    
    };
    msgs = one_msg transfered;
    e = { _eventname : "Transfer NFT"; tokenID: tokenID};
    event e;
    send msgs
end



(*Callback Transitions*)
transition getApprovedCallBack(approved_addr: ByStr20, tokenID: Uint256)
(* called back from NFT contract if approved*)  
(* get variables *)
  is_sender = builtin eq _this_address approved_addr;
     match is_sender with
        |False =>
            (*Not approved to transfer NFT*)
           delete temp_orderbook[_sender][tokenID];
           e = let raisedAt = "code_not_authorized" in makeErrorEvent raisedAt code_not_authorized;
            event e
        | True =>
            (*Approved to transfer NFT - call TransferFrom on NFT*)
            tempOrder <- temp_orderbook[_sender][tokenID];
            match tempOrder with 
                 |Some (Order owner price contractaddress tokenID orderid liststate) => 
                      (* creating listing and storing in listing mappings*)
                    transferNFTtoDEX owner tokenID
             
             
                   |None => 
                        (* failure, order not found - fire off events *)
                        e = let raisedAt = "order_not_found" in makeErrorEvent raisedAt order_not_found;
                         event e
                      end
                      
          
            end
 end

transition transferFromSuccessCallBack(from: ByStr20, to: ByStr20, tokenID: Uint256)
    tempOrder <- temp_orderbook[_sender][tokenID];
            match tempOrder with 
                 |Some (Order owner price contractaddress tokenID orderid liststate) => 
                      (* creating listing and storing in listing mappings*)
                      tempPending = "PENDING";
                      is_pending = checkOrderStatus tempPending liststate;   
                      (*Approved to transfer NFT - check orderID is pending*)
                    match is_pending with
                        |True =>
                        (* Store listing info inside the owners mappings and order mappings for references *)
                         state = "ACTIVE";
                         newOrder = Order owner price contractaddress tokenID orderid state;
                         orderbook[orderid] := newOrder;
                         delete temp_orderbook[contractaddress][tokenID]
                        (*=======================================================================================================================*)
                         (* TODO *)
                         (*add order to the list of orders for an address*)
                         
                        (*=======================================================================================================================*)
                        
                        |False =>
                         (* failure, order not pending - fire off events *)
                         e = {_eventname : "Order State invalid"; extracted_order : orderid; order_state: liststate};
                         event e
                         end
             
             
                   |None => 
                        (* failure, order not found - fire off events *)
                        e = let raisedAt = "order_not_found" in makeErrorEvent raisedAt order_not_found;
                         event e
            end
                      
end


(*Transitions*)
(* Cancel a a listing, remove it, and transfer NFT back to owner*) 
transition cancelListing (orderID : Uint256)
    listing <- orderbook[orderID];
    match listing with
    |Some (Order owner price contractaddress tokenID orderid liststate) =>  
        (*check if owner of order*)
        is_owner = builtin eq _sender owner;
        match is_owner with
        |True => 
            (*Sender is owner*)
           tempActive = "ACTIVE";
           is_active = checkOrderStatus tempActive liststate;  
                match is_active with
                |True => 
                    (*Order is active! Go ahead and delete and return NFT*)
                    delete orderbook[orderID];
                    (*transfer NFT to owner*)
                    transferNFTtoOwner contractaddress tokenID owner
                |False => 
                 (* failure, order is not active *)
                    e = {_eventname : "Order State invalid"; extracted_order : orderid; order_state: liststate};
                    event e
                end
        |False =>
         (* failure, sender not owner *)
            e = let raisedAt = "code_not_authorized" in makeErrorEvent raisedAt code_not_authorized;
                         event e 
        end
    |None => 
           (* failure, order not found - fire off events *)
            e = let raisedAt = "order_not_found" in makeErrorEvent raisedAt order_not_found;
            event e 
    end
end

(* Create a listing and sell an NFT*) 
(* First call from frontend. User wants to post an item for sale. They call this function *)
(* then it will check if approval is okay, if so, then it will transfer 721 to itself, *)
(* and create the listing information and publish it as an item for sale *)
transition sell (contractAddress: ByStr20, tokenID: Uint256, price: Uint256)    
    (* Create a temporary order that is pending to be used as reference in callbacks*)
    liststate  = "PENDING";
    orderid <- orderID;
    newOrder = Order _sender price contractAddress tokenID orderid liststate;
    temp_orderbook[contractAddress][tokenID] := newOrder;
    orderid = builtin add orderid one;
    orderID := orderid; 
     (* Check approval to see if we can transfer*)
    checkApproved contractAddress tokenID 
end
    

(* Purchase an order/NFT that is for sale*)     
transition purchase (orderID: ByStr20)    


end

(* admin functions *)
    
(*Withdrawal balance of contract *)
transition withdrawal (to: ByStr20)
end
(* Cancel an order and refund the NFT *)
transition cancelOrder (orderID: Uint256)
end
(* send NFT to person in case something goes wrong - to return their NFT and cancel order *)
transition transferNFT (contractAddress : ByStr20, tokenID: Uint256, to: ByStr20)
end







